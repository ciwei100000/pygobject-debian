From d69e5b3c7bdb9113382fd125c256b12bff4c24d2 Mon Sep 17 00:00:00 2001
From: Alberto Mardegan <mardy@users.sourceforge.net>
Date: Mon, 23 Jan 2012 12:37:26 +0200
Subject: Respect transfer-type when demarshalling GErrors

The marshaller previously ignored "transfer full" on GError* arguments, causing
crashes due to double-freeing them. This causes the testCallbackUserdata() test
case to crash after the previous GError/GHashTable marshalling fix.

Bug: https://bugzilla.gnome.org/show_bug.cgi?id=666270
---
 gi/pygi-argument.c |   12 +++++++++++-
 1 files changed, 11 insertions(+), 1 deletions(-)

Index: pygobject/gi/pygi-argument.c
===================================================================
--- pygobject.orig/gi/pygi-argument.c	2011-11-02 14:13:28.000000000 +0100
+++ pygobject/gi/pygi-argument.c	2012-01-25 07:17:11.810839994 +0100
@@ -1785,19 +1785,29 @@
             break;
         }
         case GI_TYPE_TAG_ERROR:
-             if (pyglib_error_check ( (GError **) &arg->v_pointer)) {
-                 PyObject *err_type;
-                 PyObject *err_value;
-                 PyObject *err_trace;
-                 PyErr_Fetch (&err_type, &err_value, &err_trace);
-                 Py_XDECREF (err_type);
-                 Py_XDECREF (err_trace);
-                 object = err_value;
-             } else {
-                 object = Py_None;
-                 Py_INCREF (object);
-                 break;
-             }
+        {
+            GError *error = (GError *) arg->v_pointer;
+            if (error != NULL && transfer == GI_TRANSFER_NOTHING) {
+                /* If we have not been transferred the ownership we must copy
+                 * the error, because pyglib_error_check() is going to free it.
+                 */
+                error = g_error_copy (error);
+            }
+
+            if (pyglib_error_check (&error)) {
+                PyObject *err_type;
+                PyObject *err_value;
+                PyObject *err_trace;
+                PyErr_Fetch (&err_type, &err_value, &err_trace);
+                Py_XDECREF (err_type);
+                Py_XDECREF (err_trace);
+                object = err_value;
+            } else {
+                object = Py_None;
+                Py_INCREF (object);
+                break;
+            }
+        }
     }
 
     return object;
