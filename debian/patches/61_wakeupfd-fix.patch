From the fix to the initial SETWAKEUPFD support in GNOME #481569.

--- pygobject-2.14.1/gobject/pygmainloop.c	2008-01-03 12:09:19.000000000 +0100
+++ pygobject-2.14.1.new/gobject/pygmainloop.c	2008-05-16 14:13:41.000000000 +0200
@@ -24,6 +24,7 @@
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
+#include <fcntl.h>
 
 #include "pygobject-private.h"
 #include "pythread.h"
@@ -112,7 +113,10 @@
 pyg_signal_watch_prepare(GSource *source,
 			 int     *timeout)
 {
+#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
     PySignalWatchSource *real_source = (PySignalWatchSource *)source;
+    int flag;
+#endif
 
     /* Python only invokes signal handlers from the main thread,
      * so if a thread other than the main thread receives the signal
@@ -146,6 +150,11 @@
     real_source->fd.events = G_IO_IN | G_IO_HUP | G_IO_ERR;
     g_source_add_poll(source, &real_source->fd);
 
+    /* Make the read end of the fd non blocking */
+    flag = fcntl(real_source->fds[0], F_GETFL, 0);
+    flag |= O_NONBLOCK;
+    fcntl(real_source->fds[0], F_SETFL, flag);
+
     PySignal_SetWakeupFd(real_source->fds[1]);
 
 #else /* !HAVE_PYSIGNAL_SETWAKEUPFD */
@@ -166,10 +175,19 @@
     PyGILState_STATE state;
     GMainLoop *main_loop;
 
+#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
+    PySignalWatchSource *real_source = (PySignalWatchSource *)source;
+    char buf[1];
+#endif
+
     state = pyg_gil_state_ensure();
 
     main_loop = pyg_get_current_main_loop();
 
+#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
+    read(real_source->fds[0], &buf, 1);
+#endif
+
     if (PyErr_CheckSignals() == -1 && main_loop != NULL) {
 	PyErr_SetNone(PyExc_KeyboardInterrupt);
 	g_main_loop_quit(main_loop);
